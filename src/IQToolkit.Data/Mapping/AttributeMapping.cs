// Copyright (c) Microsoft Corporation.  All rights reserved.
// This source code is made available under the terms of the Microsoft Public License (MS-PL)

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;

namespace IQToolkit.Data.Mapping
{
    using Common;
    using System.Collections.Concurrent;

    /// <summary>
    /// An attribute used to define information to help map between CLR types/members and database tables/columns.
    /// </summary>
    public abstract class MappingAttribute : Attribute
    {
    }

    /// <summary>
    /// A base type for mapping attributes that describe table-like mapping.
    /// </summary>
    public abstract class TableBaseAttribute : MappingAttribute
    {
        /// <summary>
        /// The name of the table in the database. 
        /// If not specified, the name of the entity type will be used.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The alias to use for the table reference in a query.
        /// If not specified the provider will create one.
        /// </summary>
        public string Alias { get; set; }
    }

    /// <summary>
    /// Describes the mapping between at database table and an entity type.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Property|AttributeTargets.Field, AllowMultiple = false)]
    public class TableAttribute : TableBaseAttribute
    {
        /// <summary>
        /// The CLR type that the table's contents map into.
        /// If not specified it is inferred to be the type of the class or member the attribute is placed on.
        /// </summary>
        public Type EntityType { get; set; }

        /// <summary>
        /// The ID associated with the entity mapping.
        /// If not specified it is inferred to be the name of the <see cref="EntityType"/>.
        /// </summary>
        public string EntityId { get; set; }
    }

    /// <summary>
    /// Describes the mapping between additional database tables and an entity type.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
    public class ExtensionTableAttribute : TableBaseAttribute
    {
        /// <summary>
        /// The columns in the extension table that correspond to columns in the primary table.
        /// </summary>
        public string KeyColumns { get; set; }

        /// <summary>
        /// The alias of the primary table.
        /// </summary>
        public string RelatedAlias { get; set; }

        /// <summary>
        /// The columns in the primary table that correspond to the key columns in the extension table.
        /// </summary>
        public string RelatedKeyColumns { get; set; }
    }

    /// <summary>
    /// A base class for member mapping information.
    /// </summary>
    public abstract class MemberAttribute : MappingAttribute
    {
        /// <summary>
        /// The member for the mapping.
        /// If not specified it is inferred to be the member the attribute is placed on.
        /// </summary>
        public string Member { get; set; }
    }

    /// <summary>
    /// Describes the mapping between an entity type member and a database column.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
    public class ColumnAttribute : MemberAttribute
    {
        /// <summary>
        /// The name of the column in the database.
        /// If not specified, the name of the <see cref="MemberAttribute.Member"/> is used.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The table alias the column is associate with in the query.
        /// If not specified, the provider will create one.
        /// </summary>
        public string Alias { get; set; }

        /// <summary>
        /// The type of the column as describe in the database language.
        /// </summary>
        public string DbType { get; set; }

        /// <summary>
        /// True if the column is computed by the database on insert/update.
        /// </summary>
        public bool IsComputed { get; set; }

        /// <summary>
        /// True if the column is part of the primary key of the table.
        /// </summary>
        public bool IsPrimaryKey { get; set; }

        /// <summary>
        /// True if the value of the column is generated by the database on insert.
        /// </summary>
        public bool IsGenerated { get; set; }

        /// <summary>
        /// True if the column is read-only. 
        /// Changes made on the client will be ignored during update.
        /// </summary>
        public bool IsReadOnly { get; set; }  
    }

    /// <summary>
    /// A <see cref="MappingAttribute"/> that describes an association between two entities via related column
    /// values in the tables underlying each. This is often the same as a foreign key relationship in the database.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
    public class AssociationAttribute : MemberAttribute
    {
        /// <summary>
        /// The members of the entity that form the association key.
        /// </summary>
        public string KeyMembers { get; set; }

        /// <summary>
        /// The mapping ID of the related entity.
        /// </summary>
        public string RelatedEntityId { get; set; }

        /// <summary>
        /// The type of the related entity.
        /// </summary>
        public Type RelatedEntityType { get; set; }

        /// <summary>
        /// The members in the related entity type that form the association key.
        /// </summary>
        public string RelatedKeyMembers { get; set; }

        /// <summary>
        /// True if the association's <see cref="KeyMembers"/> are foreign key columns in a table.
        /// Foreign keys are constrained to only contain values matching existing primary key values from another table.
        /// </summary>
        public bool IsForeignKey { get; set; }
    }

    /// <summary>
    /// An <see cref="AdvancedMapping"/> that is defined by <see cref="MappingAttribute"/>'s
    /// on either the entity types or on the query/table properties of a context class.
    /// </summary>
    public class AttributeMapping : AdvancedMapping
    {
        private readonly Type contextType;
        private readonly ConcurrentDictionary<string, MappingEntity> entities;

        /// <summary>
        /// Constructs a new instance of an <see cref="AttributeMapping"/> where mapping attributes are
        /// discovered on individual entity types (instead of an a context class).
        /// </summary>
        public AttributeMapping()
            : this(null)
        {
        }

        /// <summary>
        /// Constructs a new instance of a <see cref="AttributeMapping"/> where mapping attributes are
        /// discovered on a context class (instead of from the entity types).
        /// </summary>
        /// <param name="contextType">The type of the context class, where the context class has a property for each queryable table.</param>
        public AttributeMapping(Type contextType)
        {
            this.contextType = contextType;
            this.entities = new ConcurrentDictionary<string, MappingEntity>();
        }

        /// <summary>
        /// Gets the <see cref="MappingEntity"/> for the member (property/field) of a context type.
        /// </summary>
        public override MappingEntity GetEntity(MemberInfo contextMember)
        {
            Type elementType = TypeHelper.GetElementType(TypeHelper.GetMemberType(contextMember));
            return this.GetEntity(elementType, contextMember.Name);
        }

        /// <summary>
        /// Gets the <see cref="MappingEntity"/> associated with a type and table-id
        /// </summary>
        public override MappingEntity GetEntity(Type entityType, string entityId)
        {
            return this.GetEntity(entityType, entityId, entityType);
        }

        /// <summary>
        /// Gets the <see cref="MappingEntity"/> associated with an table-id, where the entity-type may different 
        /// from the element-type exposed to the user.
        /// </summary>
        private MappingEntity GetEntity(Type elementType, string entityId, Type entityType)
        {
            entityId = entityId ?? this.GetEntityId(entityType);

            MappingEntity entity;

            if (!entities.TryGetValue(entityId, out entity))
            {
                entity = entities.GetOrAdd(entityId, this.CreateEntity(elementType, entityId, entityType));
            }

            return entity;
        }

        protected static readonly MappingAttribute[] NoAttributes = new MappingAttribute[0];

        protected virtual IEnumerable<MappingAttribute> GetMappingAttributes(Type elementType, string entityId)
        {
            var list = new List<MappingAttribute>();

            if (this.contextType != null)
            {
                // get attributes from member of context that returns a collection of that element type.
                var contextMember = this.GetContextCollectionMember(elementType, entityId);

                foreach (var ma in (MappingAttribute[])Attribute.GetCustomAttributes(contextMember, typeof(MappingAttribute)))
                {
                    var table = ma as TableAttribute;
                    if (table != null)
                    {
                        if (table.EntityType == null)
                        {
                            table.EntityType = elementType;
                        }

                        if (table.Name == null)
                        {
                            table.Name = contextMember.Name;
                        }
                    }

                    list.Add(ma);
                }
            }
            else
            {
                // get attributes from elementType itself
                foreach (var ma in elementType.GetCustomAttributes<MappingAttribute>())
                {
                    var table = ma as TableAttribute;
                    if (table != null)
                    {
                        if (table.EntityType == null)
                        {
                            table.EntityType = elementType;
                        }

                        if (table.Name == null)
                        {
                            table.Name = table.EntityType.Name;
                        }
                    }

                    list.Add(ma);
                }

                foreach (var member in elementType.GetMembers(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
                {
                    foreach (var ma in (MappingAttribute[])Attribute.GetCustomAttributes(member, typeof(MappingAttribute)))
                    {
                        var memattr = ma as MemberAttribute;
                        if (memattr != null && memattr.Member == null)
                        {
                            memattr.Member = member.Name;
                        }

                        list.Add(ma);
                    }
                }
            }

            return list;
        }

        /// <summary>
        /// Gets the mapping entity id associated with an entity type.
        /// </summary>
        public override string GetEntityId(Type entityType)
        {
            if (contextType != null)
            {
                // look for entity id specified on table attribute of corresponding context member
                var members = this.GetContextCollectionMembers(entityType).ToList();

                foreach (var mi in members)
                {
                    var tableAttr = mi.GetCustomAttribute<TableAttribute>();
                    if (tableAttr != null && tableAttr.EntityId != null)
                    {
                        return tableAttr.EntityId;
                    }
                }
            }
            else
            {
                // look for entity id specified on table attribute 
                var tableAttr = entityType.GetCustomAttribute<TableAttribute>();
                if (tableAttr != null && tableAttr.EntityId != null)
                {
                    return tableAttr.EntityId;
                }
            }

            // use the entity type name as the entity id
            return entityType.Name;
        }

        private MemberInfo GetContextCollectionMember(Type entityType, string entityId)
        {
            entityId = entityId ?? this.GetEntityId(entityType);

            // look for collection member with the specified entity-id
            var members = this.GetContextCollectionMembers(entityType).ToList();
            foreach (var mi in members)
            {
                var tableAttr = mi.GetCustomAttribute<TableAttribute>();
                if (tableAttr != null)
                {
                    if (tableAttr.EntityId != null && tableAttr.EntityId == entityId)
                    {
                        return mi;
                    }
                    else if (tableAttr.EntityType != null && tableAttr.EntityType == entityType)
                    {
                        return mi;
                    }
                }
            }

            foreach (var mi in members)
            {
                if (TypeHelper.GetElementType(TypeHelper.GetMemberType(mi)) == entityType)
                {
                    return mi;
                }
            }

            throw new InvalidOperationException(string.Format("The matching member on the context type '{0}' with the entity id '{0}' cannot be found.", entityId));
        }

        /// <summary>
        /// Get all the members on the context type that are entity collections with compatible element types.
        /// </summary>
        private IEnumerable<MemberInfo> GetContextCollectionMembers(Type entityType)
        {
            return this.GetContextCollectionMembers()
                .Where(mi => TypeHelper.GetElementType(TypeHelper.GetMemberType(mi)).IsAssignableFrom(entityType));
        }

        /// <summary>
        /// Get all the members on the context type that are entity collections.
        /// </summary>
        private IEnumerable<MemberInfo> GetContextCollectionMembers()
        {
            foreach (var mi in this.contextType.GetMembers(BindingFlags.Instance | BindingFlags.Public))
            {
                FieldInfo fi = mi as FieldInfo;
                if (fi != null && TypeHelper.IsSequenceType(fi.FieldType))
                    yield return mi;

                PropertyInfo pi = mi as PropertyInfo;
                if (pi != null && TypeHelper.IsSequenceType(pi.PropertyType))
                    yield return mi;
            }
        }

        /// <summary>
        /// Create a <see cref="MappingEntity"/>.
        /// </summary>
        /// <param name="elementType">The element type if the table if it differs from entity type.</param>
        /// <param name="entityId">The mapping id of the entity.</param>
        /// <param name="entityType">The type of the entity.</param>
        private MappingEntity CreateEntity(Type elementType, string entityId, Type entityType)
        {
            if (entityId == null)
            {
                entityId = this.GetEntityId(elementType);
            }

            var members = new HashSet<string>();
            var mappingMembers = new List<AttributeMappingMember>();
            int dot = entityId.IndexOf('.');
            var rootEntityId = dot > 0 ? entityId.Substring(0, dot) : entityId;
            var path = dot > 0 ? entityId.Substring(dot + 1) : "";

            var mappingAttributes = this.GetMappingAttributes(entityType, rootEntityId);

            var tableAttributes = mappingAttributes.OfType<TableBaseAttribute>()
                .OrderBy(ta => ta.Name);

            var tableAttr = tableAttributes.OfType<TableAttribute>().FirstOrDefault();
            if (tableAttr != null && tableAttr.EntityType != null && entityType == elementType)
            {
                entityType = tableAttr.EntityType;
            }

            var memberAttributes = mappingAttributes.OfType<MemberAttribute>()
                .Where(ma => ma.Member.StartsWith(path))
                .OrderBy(ma => ma.Member);

            foreach (var attr in memberAttributes)
            {
                if (string.IsNullOrEmpty(attr.Member))
                    continue;

                string memberName = (path.Length == 0) ? attr.Member : attr.Member.Substring(path.Length + 1);
                MemberInfo member = null;
                MemberAttribute attribute = null;
                AttributeMappingEntity nested = null;

                if (memberName.Contains('.')) // additional nested mappings
                {
                    string nestedMember = memberName.Substring(0, memberName.IndexOf('.'));

                    if (nestedMember.Contains('.'))
                        continue; // don't consider deeply nested members yet

                    if (members.Contains(nestedMember))
                        continue; // already seen it (ignore additional)

                    members.Add(nestedMember);
                    member = this.FindMember(entityType, nestedMember);
                    string newTableId = entityId + "." + nestedMember;
                    nested = (AttributeMappingEntity)this.GetEntity(TypeHelper.GetMemberType(member), newTableId);
                }
                else 
                {
                    if (members.Contains(memberName))
                    {
                        throw new InvalidOperationException(string.Format("AttributeMapping: more than one mapping attribute specified for member '{0}' on type '{1}'", memberName, entityType.Name));
                    }

                    member = this.FindMember(entityType, memberName);
                    attribute = attr;
                }

                mappingMembers.Add(new AttributeMappingMember(member, attribute, nested));
            }

            return new AttributeMappingEntity(elementType, entityId, entityType, tableAttributes, mappingMembers);
        }

        private static readonly char[] dotSeparator = new char[] { '.' };

        private MemberInfo FindMember(Type type, string path)
        {
            MemberInfo member = null;
            string[] names = path.Split(dotSeparator);
            foreach (string name in names)
            {
                member = type.GetMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase).FirstOrDefault();

                if (member == null)
                {
                    throw new InvalidOperationException(string.Format("AttributMapping: the member '{0}' does not exist on type '{1}'", name, type.Name));
                }

                type = TypeHelper.GetElementType(TypeHelper.GetMemberType(member));
            }

            return member;
        }

        public override string GetTableName(MappingEntity entity)
        {
            AttributeMappingEntity en = (AttributeMappingEntity)entity;
            var table = en.Tables.FirstOrDefault();
            return this.GetTableName(table);
        }

        private string GetTableName(MappingEntity entity, TableBaseAttribute attr)
        {
            string name = (attr != null && !string.IsNullOrEmpty(attr.Name))
                ? attr.Name
                : entity.EntityId;
            return name;
        }

        public override IEnumerable<MemberInfo> GetMappedMembers(MappingEntity entity)
        {
            return ((AttributeMappingEntity)entity).MappedMembers;
        }

        public override bool IsMapped(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null;
        }

        public override bool IsColumn(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Column != null;
        }

        public override bool IsComputed(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Column != null && mm.Column.IsComputed;
        }

        public override bool IsGenerated(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Column != null && mm.Column.IsGenerated;
        }
        
        public override bool IsReadOnly(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Column != null && mm.Column.IsReadOnly;
        }

        public override bool IsPrimaryKey(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Column != null && mm.Column.IsPrimaryKey;
        }

        public override string GetColumnName(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            if (mm != null && mm.Column != null && !string.IsNullOrEmpty(mm.Column.Name))
                return mm.Column.Name;
            return base.GetColumnName(entity, member);
        }

        public override string GetColumnDbType(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            if (mm != null && mm.Column != null && !string.IsNullOrEmpty(mm.Column.DbType))
                return mm.Column.DbType;
            return null;
        }

        public override bool IsAssociationRelationship(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.Association != null;        
        }

        public override bool IsRelationshipSource(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            if (mm != null && mm.Association != null)
            {
                if (mm.Association.IsForeignKey && !typeof(IEnumerable).IsAssignableFrom(TypeHelper.GetMemberType(member)))
                    return true;
            }
            return false;
        }

        public override bool IsRelationshipTarget(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            if (mm != null && mm.Association != null)
            {
                if (!mm.Association.IsForeignKey || typeof(IEnumerable).IsAssignableFrom(TypeHelper.GetMemberType(member)))
                    return true;
            }
            return false;
        }

        public override bool IsNestedEntity(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return mm != null && mm.NestedEntity != null;
        }

        public override MappingEntity GetRelatedEntity(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingEntity thisEntity = (AttributeMappingEntity)entity;
            AttributeMappingMember mm = thisEntity.GetMappingMember(member.Name);

            if (mm != null)
            {
                if (mm.Association != null)
                {
                    Type elementType = TypeHelper.GetElementType(TypeHelper.GetMemberType(member));
                    Type entityType = (mm.Association.RelatedEntityType != null) ? mm.Association.RelatedEntityType : elementType;
                    return this.GetReferencedEntity(elementType, mm.Association.RelatedEntityId, entityType, "Association.RelatedEntityID");
                }
                else if (mm.NestedEntity != null)
                {
                    return mm.NestedEntity;
                }
            }

            return base.GetRelatedEntity(entity, member);
        }

        private static readonly char[] separators = new char[] {' ', ',', '|' };

        public override IEnumerable<MemberInfo> GetAssociationKeyMembers(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingEntity thisEntity = (AttributeMappingEntity)entity;
            AttributeMappingMember mm = thisEntity.GetMappingMember(member.Name);
            if (mm != null && mm.Association != null)
            {
                return this.GetReferencedMembers(thisEntity, mm.Association.KeyMembers, "Association.KeyMembers", thisEntity.EntityType);
            }
            return base.GetAssociationKeyMembers(entity, member);
        }

        public override IEnumerable<MemberInfo> GetAssociationRelatedKeyMembers(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingEntity thisEntity = (AttributeMappingEntity)entity;
            AttributeMappingEntity relatedEntity = (AttributeMappingEntity)this.GetRelatedEntity(entity, member);
            AttributeMappingMember mm = thisEntity.GetMappingMember(member.Name);
            if (mm != null && mm.Association != null)
            {
                return this.GetReferencedMembers(relatedEntity, mm.Association.RelatedKeyMembers, "Association.RelatedKeyMembers", thisEntity.EntityType);
            }
            return base.GetAssociationRelatedKeyMembers(entity, member);
        }

        private IEnumerable<MemberInfo> GetReferencedMembers(AttributeMappingEntity entity, string names, string source, Type sourceType)
        {
            return names.Split(separators).Select(n => this.GetReferencedMember(entity, n, source, sourceType));
        }

        private MemberInfo GetReferencedMember(AttributeMappingEntity entity, string name, string source, Type sourceType)
        {
            var mm = entity.GetMappingMember(name);
            if (mm == null)
            {
                throw new InvalidOperationException(string.Format("AttributeMapping: The member '{0}.{1}' referenced in {2} for '{3}' is not mapped or does not exist", entity.EntityType.Name, name, source, sourceType.Name));
            }
            return mm.Member;
        }

        private MappingEntity GetReferencedEntity(Type elementType, string name, Type entityType, string source)
        {
            var entity = this.GetEntity(elementType, name, entityType);

            if (entity == null)
            {
                throw new InvalidOperationException(string.Format("The entity '{0}' referenced in {1} of '{2}' does not exist", name, source, entityType.Name));
            }

            return entity;
        }

        public override IList<MappingTable> GetTables(MappingEntity entity)
        {
            return ((AttributeMappingEntity)entity).Tables;
        }

        public override string GetAlias(MappingTable table)
        {
            return ((AttributeMappingTable)table).Attribute.Alias;
        }

        public override string GetAlias(MappingEntity entity, MemberInfo member)
        {
            AttributeMappingMember mm = ((AttributeMappingEntity)entity).GetMappingMember(member.Name);
            return (mm != null && mm.Column != null) ? mm.Column.Alias : null;
        }

        public override string GetTableName(MappingTable table)
        {
            var amt = (AttributeMappingTable)table;
            return this.GetTableName(amt.Entity, amt.Attribute);
        }

        public override bool IsExtensionTable(MappingTable table)
        {
            return ((AttributeMappingTable)table).Attribute is ExtensionTableAttribute;
        }

        public override string GetExtensionRelatedAlias(MappingTable table)
        {
            var attr = ((AttributeMappingTable)table).Attribute as ExtensionTableAttribute;
            return (attr != null) ? attr.RelatedAlias : null;
        }

        public override IEnumerable<string> GetExtensionKeyColumnNames(MappingTable table)
        {
            var attr = ((AttributeMappingTable)table).Attribute as ExtensionTableAttribute;
            if (attr == null) return new string[] { };
            return attr.KeyColumns.Split(separators);
        }

        public override IEnumerable<MemberInfo> GetExtensionRelatedMembers(MappingTable table)
        {
            var amt = (AttributeMappingTable)table;
            var attr = amt.Attribute as ExtensionTableAttribute;
            if (attr == null) return new MemberInfo[] { };
            return attr.RelatedKeyColumns.Split(separators).Select(n => this.GetMemberForColumn(amt.Entity, n));
        }

        private MemberInfo GetMemberForColumn(MappingEntity entity, string columnName)
        {
            foreach (var m in this.GetMappedMembers(entity))
            {
                if (this.IsNestedEntity(entity, m))
                {
                    var m2 = this.GetMemberForColumn(this.GetRelatedEntity(entity, m), columnName);
                    if (m2 != null)
                        return m2;
                }
                else if (this.IsColumn(entity, m) && string.Compare(this.GetColumnName(entity, m), columnName, true) == 0)
                {
                    return m;
                }
            }
            return null;
        }

        public override QueryMapper CreateMapper(QueryTranslator translator)
        {
            return new AttributeMapper(this, translator);
        }

        private class AttributeMapper : AdvancedMapper
        {
            private readonly AttributeMapping mapping;

            public AttributeMapper(AttributeMapping mapping, QueryTranslator translator)
                : base(mapping, translator)
            {
                this.mapping = mapping;
            }
        }

        private class AttributeMappingMember
        {
            private readonly MemberInfo member;
            private readonly MemberAttribute attribute;
            private readonly AttributeMappingEntity nested;

            public AttributeMappingMember(MemberInfo member, MemberAttribute attribute, AttributeMappingEntity nested)
            {
                this.member = member;
                this.attribute = attribute;
                this.nested = nested;
            }

            internal MemberInfo Member
            {
                get { return this.member; }
            }

            internal ColumnAttribute Column
            {
                get { return this.attribute as ColumnAttribute; }
            }

            internal AssociationAttribute Association
            {
                get { return this.attribute as AssociationAttribute; }
            }

            internal AttributeMappingEntity NestedEntity
            {
                get { return this.nested; }
            }
        }

        private class AttributeMappingTable : MappingTable
        {
            private readonly AttributeMappingEntity entity;
            private readonly TableBaseAttribute attribute;

            public AttributeMappingTable(AttributeMappingEntity entity, TableBaseAttribute attribute)
            {
                this.entity = entity;
                this.attribute = attribute;
            }

            public AttributeMappingEntity Entity
            {
                get { return this.entity; }
            }

            public TableBaseAttribute Attribute
            {
                get { return this.attribute; }
            }
        }

        private class AttributeMappingEntity : MappingEntity
        {
            private readonly string tableId;
            private readonly Type elementType;
            private readonly Type entityType;
            private readonly ReadOnlyCollection<MappingTable> tables;
            private readonly Dictionary<string, AttributeMappingMember> mappingMembers;

            public AttributeMappingEntity(Type elementType, string tableId, Type entityType, IEnumerable<TableBaseAttribute> attrs, IEnumerable<AttributeMappingMember> mappingMembers)
            {
                this.tableId = tableId;
                this.elementType = elementType;
                this.entityType = entityType;
                this.tables = attrs.Select(a => (MappingTable)new AttributeMappingTable(this, a)).ToReadOnly();
                this.mappingMembers = mappingMembers.ToDictionary(mm => mm.Member.Name);
            }

            public override string EntityId
            {
                get { return this.tableId; }
            }

            public override Type ElementType
            {
                get { return this.elementType; }
            }

            public override Type EntityType
            {
                get { return this.entityType; }
            }

            internal ReadOnlyCollection<MappingTable> Tables
            {
                get { return this.tables; }
            }

            internal AttributeMappingMember GetMappingMember(string name)
            {
                AttributeMappingMember mm = null;
                this.mappingMembers.TryGetValue(name, out mm);
                return mm;
            }

            internal IEnumerable<MemberInfo> MappedMembers
            {
                get { return this.mappingMembers.Values.Select(mm => mm.Member); }
            }
        }
    }
}
